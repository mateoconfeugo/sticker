* Provisioning, Developing, Releasing, Deploying, Maintaining 
How to be a one armed paper hanger
Using pallet, lein, vmfest, expections and clj-driver to automate your development provisioning release deployment testing system admin stuff
especially if running a web based service.

* What is my Approach?
By effectively combining the various use of clojure libraries one can eliminate 
 much of the drudgery of developing, testing, releasing, deploying and maintaining software
* What are the features that make that happen
Provide major components of a continuous delivery system
Programmatically provision system resources
Run your system of many servers on different providers  via simple single command line commands
Automated end to end testings
Test your system in the different computing environments with real servers and real web browsers
Organize and automate your common tasks in a easily reusable way.
* Pieces
Clojure
Pallet
Lein
Vmfest
Expectations
clj-driver

* Clojure?
Its a lisp based programming language that runs on the java virtual machine and it takes the form of a java library so all sorts of interop is possible and pretty easy.  Clojure does demand you raise your game and pays you richly for doing so.  Clojure is a very powerful pragmatic language thats not very dogmatic. 

* What is pallet?
** They say
Pallet is platform for agile and programmatic automation of infrastructure in the cloud, on server racks or directly on virtual machines. Pallet provides cloud provider and operating system independence, and allows for an unprecedented level of customization.
Pallet is a clojure libary that compiles DSL functions  down to a set shell commands which are run across an ssh connection.

* Pallet Concepts
** The Node
** Node Specs
** The Computing Service Provider
*** Getting Setup
**** Access 
**** Controlling your environment
** Server Specs
** Group Specs
** Operations
*** Converge
*** Lift
** Crates
** Actions

* What is lein?
Leiningen is the easiest way to use Clojure. With a focus on project automation and declarative configuration, it gets out of your way and lets you focus on your code. lein is the command line implemenation tool of the leiningen project.

* Lein concepts
** Plugins

* What is vmfest?
VMFest is a PalletOps project to turn VirtualBox into a light-weight cloud provider. This is very useful for when developing cloud automation. VirtualBox's Virtual Machines (VMs) boot very quickly (seconds), so why not take advantage of it?
VMFest takes the form of a library, and you can use it as a toolkit to create your own virtualization environments.

* What is clj-driver
This is a Clojure library for driving an actual web browser using Selenium-WebDriver as the backend. This allows you to acturatelly run simulation of user interations with your application.  Provides higher-level Clojure functions to make interacting with the browser easier.

* What is expectation 
expectations is a minimalist's testing framework
Simply require expectations and your tests will be run on JVM shutdown.
What you are testing is inferred from the expected and actual types
Stacktraces are trimmed of clojure library lines and java.lang lines
Focused error & failure messages

* How it works together to make your life easier

** lein pallet plugin
A leiningen plugin for running pallet tasks for a pallet deployment project.
*** How to
Make a Crate
Pass arguments to converge/lift operations

** Release/Deploy/Maintain on the following conceptal system environments
*** Locally - dev
*** On virtual machines  running locally - dev-qa
*** On cloud test servers
*** On cloud QA servers
*** On cloud production blue
*** On cloud production green

** lein expectations
A leiningen plugin to make running tests written using expectations library.

** lein autoexpect 
Leiningen plug-in for automatically running expectations whenever your Clojure project's source changes.

* Organize
How you organize all this is key 
** [project-name].nodes.[domain-of-concern]
** [project-name].servers.[domain-of-concern]
** [project-name].groups.[domain-of-concern]

*Examples of the different operations 
**  lein pallet  converge monitoring.groups.monitoring/monitoring 2 -P :vmfest
Create 2 virtual box instances of the node described in the ~/.pallet/services/vmfest.clj file and name them according to the group spec referred via its namespace. 
** lein pallet  lift monitoring.groups.monitoring/monitoring  -P :vmfest
Apply the server-specs to the specified group of existing nodes
**  lein pallet  converge monitoring.groups.monitoring/monitoring 0 -P :vmfest
Teardown the system
**  lein pallet  converge monitoring.groups.monitoring/monitoring 1 -P :qa-cloud
creates 1 node in the cloud with a qa node and installs the monitoring group specification 

** Testing aspect
Tests can spin up the system in the desired environment and have control the web browser
to perform actions against the system then check the various pieces to test for the desired
affect. Using autoexpect you can always be running your tests as you run your system in 
a local environment or on virtual boxes.  Since pallet is just a library its very easy to
programmaticaly do whatever.

* Typical system
** Load balancer ???
** Web server proxy (nginx)
** Database server (mysql)
** Configuration Server (zookeeper)
** File Server (nfs)
** Application Server wine-celler.jar

* System Admin Task Areas
;;======================================================================
;; Server specifications: These are the servers that make up a 
;; onlines physical presence
;; Things to specify
;; 1: Users and Groups
;; 2: Application and 3rd Party Packages
;; 3: Cronjobs
;; 4: Services
;; 5: Files
;; 6: Symbolic Links
;;======================================================================

What files need to be put in place
* Application libraries
* Startup and supervise scripts
* Third party dependencies
* CMS published files
* configuration files

* Provisioning scenarios
The software is run several different environments
** DEVELOPMENT
Every thing runs local on the developers single box.   The testing
suite is run from the same box.  This scenario is what is used when
the developer has created a feature branch and working locally  where
they can't do any damage.   All the java dependencies are satified
using a local maven repository.  This scenario employs  lein
autoexpect plugin so that the testing suite is always running.

** DEV QA
Everything is checked out and built from scratch on the host and deployed from there
to virtual box machines the host spins to  simulate the production
infrastructure  the various parts of the system.   The host then runs
the acceptance tests against the virutal system before the feature
branch is merged back into the  delvelopment branch.  Then the
develop branch publishes the feature into github.

** QA RELEASE
Testing scenarios can be run on  the cloud hosted node/box/machine.
The ops/qa  starts is process of getting, building, package,
provisioning and deploying  when a release is started.  The ops/qa
server will then run the acceptance tests against against the system
it just spun up.  
 When the acceptance test pass its time to finish the release.  
*** This will mean the release branch is merged into develop and into master
*** The master branch is tagged
*** The release branch is removed
*** The newly spun up QA environment is now the blue/green environment depending on what production is

** PRODUCTION RELEASE
The overall idea is the traffic will slowly be shunted from the
previous releases prod environment to the environment that was spun up
in the QA RELEASE.  When it deemed save the ratio of resources in
shifted from the previous release production environement to the new
release and the new releases color is now set to production.  Then all
the traffic is shunted to the new release and the old environment
sticks around with all  the system now running on minimal resource.
And will exist untill the next  new release.  The only thing that
needs to be running is probably the databases that now are the
replication slaves

customers can choose between sharing resources (less
expensive) or having their own deicated servers in the cloud


*** FLOURISH ASSETS
**** Databases
***** Shared amongst clients
***** Internal
**** Flourish Online Servers

*** CUSTOMER ASSETS



All the servers that make up system can be run as any user


** DEVELOPMENT
NEW DEVELOPMENT SETUP ON EXISTING NODE (developer laptop)
** Checkout project and publish cms resources to a pre-existing box (node)
** This will require a pallet crate that manipulates bricolage
** Checkout Git
** determine what user to run under


** TEST
All These senarios will have to check out the source and build the
individual pieces from scratch.  These parts are then used  in the
following TEST scenarios
* COMPLETE SYSTEM RUNNING LOCALLY  SHARED LIBRARIES
** CONDITIONS Requirements
*** All the java servers are bundled up in jar file and uses the dependencies in the local .m2 repository
*** Each server running as a unique unix user but part of a common group
*** All acceptence, component, and unix test can run  without any internet connection

* COMPLETE SYSTEM RUNNING LOCALLY  UBERJARS
All the java servers are bundled up in single file standalone uberjars

* COMPLETE SYSTEM RUNNING ON LOCALLY HOSTED VIRTUAL MACHINES

* INDIVIDUAL SERVERS AND DEPENDENCIES RUNNING LOCALLY

* INDIVIDUAL SERVERS AND DEPENDENCIES RUNNING ON LOCALLY HOSTED VIRTUAL MACHINES




