The Site Builder is an authoring tool that users easily create responsive optimized landing marketing microsites.
The purpose of these microsites maximize the conversions possible with the traffic it receives.

Consists of a set of tools that allows the user to:
* Graphically create their website.
* Integrated Content Management System.
* Create custom CMS Documents.
* Easily bind CMS content and static content together.
* Work on sites collaboratively
* Publish both the site and the content that populates the site independently

So what makes this flexible authoring system a unique  product is that it combines together:
* Content Management System that allows the creation of arbitraly complex documents.
* Drag and Drop HTML Layout builder that makes the creation of the structural parts of the site simple. 
* CSS Editor that allows for the site to be styled however the designer wants.
* The HTML, CSS, Javascript code that is generated is very human readable and tries to follow the best practices
* The straight forward way of binding document content into the various parts of the site.
* Quickly switch views from editing, css, designer, preview, content allows smooth user workflow.

The web content management system  (WCMS) aspect of the site builder supports things like 

* Automated templates
Create standard output templates (usually HTML and XML) that can be automatically applied to new and existing content, allowing the appearance of all content to be changed from one central place.

* Access control
Some WCMS systems support user groups. User groups allow you to control how registered users interact with the site. A page on the site can be restricted to one or more groups. This means an anonymous user (someone not logged on), or a logged on user who is not a member of the group a page is restricted to, will be denied access to the page.

* Scalable expansion
Available in most modern WCMSs is the ability to expand a single implementation (one installation on one server) across multiple domains, depending on the server's settings. WCMS sites may be able to create microsites/web portals within a main site as well.

* Easily editable content
Once content is separated from the visual presentation of a site, it usually becomes much easier and quicker to edit and manipulate. Most WCMS software includes WYSIWYG editing tools allowing non-technical users to create and edit content.

*Scalable feature sets
Most WCMS software includes plug-ins or modules that can be easily installed to extend an existing site's functionality.

* Web standards upgrades
Active WCMS software usually receives regular updates that include new feature sets and keep the system up to current web standards.

* Workflow management
workflow is the process of creating cycles of sequential and parallel tasks that must be accomplished in the CMS. For example, one or many content creators can submit a story, but it is not published until the copy editor cleans it up and the editor-in-chief approves it.

* Collaboration
CMS software may act as a collaboration platform allowing content to be retrieved and worked on by one or many authorized users. Changes can be tracked and authorized for publication or ignored reverting to old versions. Other advanced forms of collaboration allow multiple users to modify (or comment) a page at the same time in a collaboration session.

* Delegation
Some CMS software allows for various user groups to have limited privileges over specific content on the website, spreading out the responsibility of content management.[6]
Document management

* CMS software may provide a means of collaboratively managing the life cycle of a document from initial creation time, through revisions, publication, archive, and document destruction.

* Content virtualization
CMS software may provide a means of allowing each user to work within a virtual copy of the entire web site, document set, and/or code base. This enables changes to multiple interdependent resources to be viewed and/or executed in-context prior to submission.

* Content syndication
CMS software often assists in content distribution by generating RSS and Atom data feeds to other systems. They may also e-mail users when updates are available as part of the workflow process.

* Multilingual
Ability to display content in multiple languages.

* Versioning
Like document management systems, CMS software may allow the process of versioning by which pages are checked in or out of the WCMS, allowing authorized editors to retrieve previous versions and to continue work from a selected point. Versioning is useful for content that changes over time and requires updating, but it may be necessary to go back to or reference a previous copy.

Advantages
* Low cost
Others may be affordable based on size subscriptions. Although subscriptions can be expensive, overall the cost of not having to hire full-time developers can lower the total costs.

* Easy customization
A universal layout is created, making pages have a similar theme and design without much code. Drag and drop AJAX system for design modes. It makes it easy for beginner users to create custom front-ends.

*Easy to use
Designed with non-technical marketing people in mind. Simplicity in design of the admin UI allows website content managers and other users to update content without much training in coding or technical aspects of system maintenance.

* Workflow management
Facility to control how content is published, when it is published, and who publishes it. Some WCMSs allow administrators to set up rules for workflow management, guiding content managers through a series of steps required for each of their tasks.

* Good For SEO
CMS websites are also good for SEO. Freshness of content is one factor that helps, as it is believed that some search engines give preference to website with new and updated content than websites with stale and outdated content. Usage of social media plugins help in weaving a community around your blog. RSS feeds which are automatically generated by blogs or CMS websites can increase the number of subscribers and readers to your site. Url rewriting can be implemented easily which produces clean urls without parameters which further help in seo. There are plugins available that specifically help with website seo.

Disadvantages our approach solves

* Cost of implementation
Larger scale implementations may require training, planning, and certifications. Certain CMSs may require hardware installations. Commitment to the software is required on bigger investments. Commitment to training, developing, and upkeep are all costs that will be incurred for enterprise systems.[10]

* Cost of maintenance
Maintaining CMSs may require license updates, upgrades, and hardware maintenance.

* Latency issues
Larger CMSs can experience latency if hardware infrastructure is not up to date, if databases are not being utilized correctly, and if web cache files that have to be reloaded every time data is updated grow large. Load balancing issues may also impair caching files.

* Tool mixing
Because the URLs of many CMSs are dynamically generated with internal parameters and reference information, they are often not stable enough for static pages and other web tools, particularly search engines, to rely on them.

The challanges to providing a flexible authoring system for generating the semantic content that is tolerable for other humans to look at:
* creating content host dom components, 
* organizing layout
* applying style to the populated dom
* creating meta data about the semantic content for automated agents
* connecting javascript applications up to the DOM.
* storing the semantic content

WHY IS THIS IMPORTANT:
The modern website of which these  responsive optimized landing marketing microsites (ROLMM's) are a subset are made from several differnt types of content.

Types of content
* Semantic content
* semantic content hosting dom
* Meta data content
* Structure
** The elements that create the boiler plate for any well thought out page
** The framework that creates the  layout of a site and some of these layout nodes will be the parents of the content hosting dom nodes
* Style
** Style for the layout
** Style for the device
** Style for the presentation
* Resources
** Javascript
** Images/Videos
** static files

BUT WHY IS IT IMPORTANT
In combination with the ad generation online campaign tools the site builder completes the toolset of the online marketer giving them
a tool that allows them to carry the scent forward from the keyword, ad, site, offer conversion, reporting and monitoring.  

The tool creates a coherent unit of marketing effort organization.  
This makes creating, maintaining, monitoring and improving marketing campaigns easier.

Further this tool allows for all the myrid of devices to consume the end publised content.

* BACKGROUND

The thing that makes it a challenge is there needs to be multiple ways the content tree is going to be viewed.
From the point of view as an authoring tool and for how it is to looked when rendered DOM and running in a browser.
These accompaning data structures together start to form an more accurate image of the total lifecycle of a webpage.
DOM stands for document object model and serves as the top of the data structure; however, HTML provides the ability to inject other
complete pages into one another.

This composistion ability is what allows the incredibly flexiblity in how the content is organinzed and how it is presented to the user

The cms semantic content data structure is also the document.  As the page DOM provides interface the web browser can process this semantic content document
forms the top level object that nosql document stores use.

As a web page is a instance of a pattern seen in software.
Tree data being manipulated by an asynchronous process hosted by a operating system.
The tree being the rendered DOM the processes being javascript apps and the os being the the browser.
What is the purpose of the DOM? To provide the structural framework to host meaningful content.

HTML hypertext markup language:
Human Translated Meaning Linked
HTML is for people.  It purpose is to present content in such a way that they can digest it and it is meaningful to them.
Because its for people there are some aspects of the data that need to be there that aren't necessary for non-human consumers of the content data

Organizing the Semantic content and storing it is the job of a content management system. 
The organizing content construct needs to be similary flexible as the DOM is so arbitrary complex content trees can be created.

Documents are just elements that can have fields or other elements.  Some of the fields are manditory so as to provide meta data that will be used by the semantic editor 
data as well as the published DOM.

Other program data object that will be necessary are some relations that tie the various data structures in a cohertant manner so that the content can be published into 
the desired dataformat

Transform functions provide the mechanism of mapping the CMS data structures into web page DOM.
The transformation function is generated by a macro that brings together selector functions, html dom snippets, and the content data.
The macro allows for the create of functions that allow this mapping from the CMS domain to the HTML DOM in an arbitrary manner.

* Want
The sitebuilder authoring tool should be very simple to use, maintain and add features to.

** Given
In this sitebuilder system business workflows are series of data transformations applied against arbitrary deep hierarchtical trees

** Know
Seperating the program control from the manipulation of the business data simplifies program design, coding and maintenance.
These transforms are represented as pipes and the maps flow in and out.  .  
Business data in the form of maps are passed between pipe which transform them.
Connecting these pipes in series forms pipelines.
These pipelines are what accomplish the business functionality of the system.

** Solution
The business logic on the server side of the sitebuilder is to be built in the streaming data pipeline style.

** Client Side Description of the Tool
User can switch between the following modes of operation which allows for the authering of the different data structures 
that together make up the whole custom application being created.
* Site Map View
* Site Layout Edit
* Site Style Edit 
* Content Editing - working with the pure content
* Document Design - building custom documents
* Document Browsing - Search documents to be able to associate with the site and page.
* Site View - whole stylesheet
* Mixed Mode - Content and Site Layout Mode
* Workflow Desk View
* Dashboard

Tools allows the user to select components (HTML, CMS) from a list of existing components 
either to insert into the page dom or create a new component.  Using javascript drag and drop
events the information about the dom to insert and the dom where the insertion is to take place
is sent to the sever.

The repeating pattern used through this application is to create a feedback loop:
from the user -> browser -> webapp -> browser

(defpipeline add-component 
  validate-insertion
  create-snippet-template
  build-snippet-function
  update-deftemplate
  update-html-template
  push-to-editor)

Underneath the covers the user is causing some clojure macros to be written to a file.
These macros will be evaluated and the resulting functions they produce will be used in
two places.  First to provide the response to the request that caused the edit so as to provide the 
use with visual feedback.  Second, when the microsite is being servered by the  landing site delivery
engine it is these same functions that will transform and integrate the snippets, contents and resources
together into the index page that is served to the end consumer of the site.

here is the cms map structure 
Schema:
{:fields [{:keys [name type value]}]
 :elements [{:keys [name fields]}]}

Maps will be produced by constructor functions for the various business data structures that will
include the required fields and elements thus defining the structure.

Relations

Semantic Content <-> Content Editor  these two thing make up a content component
Semantic Content <-> Meta data
Semantic Content <-> The Location in the website resource hierachy hosted and served by the web application server
Semantic Content <-> The transformtion function 
Meta Data <-> The transformation function
Transformation function <-> Publishing Channel
HTML DOM <-> Publishing Destination
Site <-> Semantic Content 
User/Group <-> Semantic Content
User/Group <-> Site
Semantic Content <-> Resource
CMS Document Status - workflow desk

The data that the CMS stores seems to be broken down in to several differnt parts
* The Document 
* The Site 
* Users/Groups
* Snippets
* HTML Templates
* Channels
* Contributors
* Work Desks

Differnt types of data might do better in different types of data stores
* Document Database
Document Content
Site Layout
Content Meta data
* Filesystem
HTML Templates
snippets
* Database
Relation Data

Reuse administrative relational resources from bricolage
Use key value document store like Cassandra or MongoDB

Types of content
* Semantic content
* semantic content hosting dom
* Meta data content
* Structure
** The elements that create the boiler plate for any well thought out page
** The framework that creates the  layout of a site and some of these layout nodes will be the parents of the content hosting dom nodes
* Style
** Style for the layout
** Style for the device
** Style for the presentation
* Resources
** Javascript
** Images/Videos
** static files

The node tree allows for all of these types of content.  Being such a flexible data structure it is possible to create whatever type of tree, subtrees you need.

This is an authoring tool and it cause the following artifacts to be produced for the user

Filesystem resources and directory structure:  These will get deployed
/domain
  /site
     /cms-resources
        /templates
	  base.html
          elements.html
        /snippets
        /views
          host_dom.clj
   /landing-site
      /name
         name.json
         page.html
   /market-vector
   /market-matrix

Document Database Resources and Hierachy used only when using authoring tool

user-|
     |- domain
     	     |- documents
	     |- content-bindings  snippet <-> deconstrutor map
	     |- meta-data

combine existing landing-site json doc into couch db
integrate dynamically generated html templates and clojure code into the existing directory structure
create content editing panel 
	
Here is where clojure being a lisp and lisp being homoiconic is very key to simplifiy things when creating the
mechanisim for the site builder

For existing component
{:component-name "foo"
 :target-dom "bar"}

New Component
{:component-name "ham"
 :html "<div>Ham</div>"}

The elements inside the editor dom that the user drags the components into is what the page will look like rendered.
This piece of dom is being updated via a post callback success event or socketio is the page html as it is on the server.
There is an actual file in the templates directory that is being changed as well as a compojure style view and if a new component
a new snippet is being added to the snippets directory.  With these resource updated with the posted data the request is piped through
these resources and the output sent to the browser to be put editor dom.  This also provides for some validation and business rules to be applied

Inserting the content into the hosting dom is the job of the element editor.
Mapping the element field values to right place in the component dom is the job of the snippet functions.

These snippets take a selector which the target dom data from the post provided and a map of the
element with all the fields and subelements populated.

The transform function the deftemplate macro produces will take as arguments:
 the cms content document
 the snippet-deconstructor binding map.

Each rule will consist of the selector, the snippet function.
The snippet function will take as its argument  the relevant part of the content document 
The deconstructur tied to the snippet to will be used to extract the data from the content

This application is going to produce clojure code files and the code in those files will be run to accomplish the sitebuilder.

The most complicated part of this the snippet function itself as the html, location in the dom and model data is already being provided.
For the short term there can just be a input box where one can write the clojure code until a way to automate the process is written.

The trick is mapping the content from potentially many document elements to the framework page's components that present the content
Probably could use uri into the document store that can be bundled to a single viewable url.
When binding document content to hosting container the user can select amonst the documents to apply the deconstruction selector.

Both the base structure and functionality  the site includes as well as the content can be independantly release/published.

A -> B
* Write the html sent from editor to the base.index.html file in the correct place in the directory
* Write the css sent from editor to the base.index.html file in the correct place in the directory
* Update/create the clojure file that contains the deftemplate - Remember code is data. you can read the clj file as a list using read-string modify it and write it back.
use *print-dup* to serialize and deserialize the code.
* Figure out how to edit the code that has been serialized into a data structure. How do macros figure into this.
* Once the code has been deserialized back into the file when and how is it evaluated so that the function created by the deftemplate becomes operative

Combine the parts of the management application together
Get document store going going to use couch db

A Site map control could help organize the seperate html document of the site.
A Web app might present these all in a single download or dom 
http://boagworld.com/demos/sitemap/#

Want to reuse the work for the layoutit engine

The site builder editor creates the base website and template that is then used by the landing-site delivery engine along with 
the cms documents.

One of the main features is that actual content from the cms is able to be viewed as the designer or content editor changes the site framework html, 
container components.

Things to take from Vix
Exception handler
Lucene Document Search - Site Search
Support for multiple languages
Attachment Support
CouchDB related code

Things to take from FCMS
Entity Item - Collection
Linking Stragtgy 
Resource strategy

* How the content data is organized

Using the everything is maps strategy
Map Entity Collection Document 
Mapping into Couch

How do Entitys Map to WCMS level concepts
Elements - Fields  <-> Collections and Items
An Element is made up of a Field Item and a Elements Collection

Items can be access via a uri.
Binding Item data to the model passed to a particalur snippet function can be a function that takes a uri and returns the data
So an Element field values can be accessed in a single reguest and a collection of sub elments links can also be retreived.
This will all snippets to have sub snippets that take an element link and handle the dom creation for that element.

(defmacro defbinding  [name selector snippet uri]
   `(defn name [selector snippet uri]
       [selector] '(snippet (get-cms-data uri))))



Want to leverage all that the liberator REST framework offers

* Represent our top level concepts as resources.
Landing Site
WebPage
Documents
Market Vectors
Market Matrix
Campaigns
Ad Groups
Ads
Offers
ClientSideWebApp
Publishers
Sources
SubID
Feeds
Feed Provider
White Box Network Resellers
Ad Tiers
Ad Channels

Define what operations can occur on 


What Groups Exist
Admin
Operations
Network Operations
Landing Site Operations
Content Editing
HTML Editing
Marketing Operations
Syndication Operations

Intergration with Liberator

Things to take from Bricolage
Some of the schema
Design concepts - Documents, Elements fields, channels, destintations, Sites, Groups, Contributors, Workflows
Instance of Landing Site and elements that make it up

What the entity store using links allows us is to step even one layer up and build a tool that allows itself
to be manipulated as it is used.

the webclient part of the web application has a bootloader so to speak.
The main function asks the server for a configuration json file.  The application 
then uses those settings to connect the views to their models and templates, models and collections to their
rest uri.

Since we can get the location of the drag and drop and using the inserted dom create a new base template from which to work with.
the clientconfig document gets transformed thusly
inserted dom and future contents serve as the template html for the display object, the host_element is the xpath statement.
Depending on whether the display object is a list or item type a collection or model can be added to the model collection part of the config document.  To go a step further lets add several more fields
for the router  view model and collections common top level elements add a code field that allows us to put javascript code directly into the database.

Things todo:

* Get project compiling
* Get expectation working
* Get autoexpect to work
* Get clutch working
* Insert client config into database
* Create basic display object editor javascript
backbone view, model, collection
HTML template shared for both enlive and underscore template
enlive template view
controller
liberator resource
model
* Build simple component and have it show up in the editor
wrap the layoutit editor
* Organize management application

* Insert the following buttons into the HTML structure editor that will trigger:
When you drag and drop elements with the layout manager these buttons allow you to combine cms, style, editing, behaviour as you create
while organizing all this effort in a very human readable way

CMS - start editing cms content right away allows user to select document and data from document and bind it to the display object
CSS - The style sheet edtior will activate and one can manipulate the style elements and see the result
BB -  Backbone user can create inline backbone views models and collections these components will be added to list of exiting components
JS - Add an existing resource to the project

Anticipated workflow

* Switch to application builder mode
This mode takes the default managent base html template and renders it in the Item part of the editor
* User drags a container type div into the the management app view within the tool
* User adds more content displaying dom elements into the container
* User clicks the css button and manipulates the style this style is feed back to the server that updates the css stylesheet document/file
* This new style is used as the management base html is rendered again and sent back to the tools app view.
* click add media brings in image video audio file
* User clicks the BB button and a tabbed overlay allowing the user to create inline backbone model, views, collections
this all gets sent back to the server updates the javascript tag and renders the enlive template and once again sends it
back to the tools app view where now the dom is connected to javascript.
* Also this combination of javascript backbone code, the contained html, as well as the uris that feed the backbone models and 
collections are now a display object and are added to the tools list in the Collection part of the editor.
* Organize the display objects into tool level dashboards
* Save tool level resources
* Add tool to overall application
* Organize the default application level dashboards
* Publish the resources that make up the management application into the correct locations of the project directory.
* Deploy new version of management application code as well as configuration data.
* Deploy new version of management application administration data.

Try to have each work effort change an acceptance test from true to false.



Display objects can be added inline or as a javascript library.
The base editor should allow for a libraries to be added satifiying the dependencies and bootloader

combining cms management into main tool
This will allow for the base html dom page, the main css, and perhaps
assemble the javascript in a sensible fashion


Since elements and fields have types we can use the the derive and
make heirachy clojure functions to create the relationships and then
create a multi method that 


The lucene ability allows for site search feature


Since its all elements built upon elements some of the basic first components to be made are:
<div>
<nav>
<section>
<ul>
<ol>
<aside>
<canvas>
<article>
<style>
<script>
<header>
<head>
<body>
<html>
<link>
<table>

on drop the xpath statement and


>
